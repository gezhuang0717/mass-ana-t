/*
 * IF YOU ARE LOOKING AT A .c FILE, YOUR ARE LOOKING AT THE WRONG ONE
 *
 * The .c file is autogenerated from a .rl source file for 'ragel'
 * parser generator.
 */
/*
	This file is part of libejson.
	
	(C) 2010 Michel Pollet <buserror@gmail.com>
	
	libejson is free software: you can redistribute it and/or modify
	it under the terms of the GNU Lesser General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.
	
	libejson is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Lesser General Public License for more details.
	
	You should have received a copy of the GNU Lesser General Public License
	along with libejson.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <alloca.h>

#include "ejson.h"

%%{
	machine ejson_str;
	write data;
}%%

static char * ejson_append_utf8_glyph(
	char * dst,
	unsigned long inUnicode )
{
	if (!(inUnicode & ~0x7f)) {
		*dst++ = ((char)inUnicode);
		return dst;	// that was easy
	}
	unsigned char *cur = (unsigned char*)dst;

	unsigned long currentMask = ~0x7ff;
	int bits = 6;
	int header = 5;

	while ((inUnicode & currentMask) && bits <= 24) {
		currentMask = currentMask << 6;
		bits += 6; header--;
	}
	*cur++ = (0xfe << header) | (unsigned char)(inUnicode >> (bits));
	bits -= 6;
	while (bits >= 0) {
		*cur++ = 0x80 | ((unsigned char)(inUnicode >> bits) & 0x3f);
		bits -= 6;
	}
	return (char*)cur;
}

int ejson_parse_string(const char * str, const char *end, char * out)
{
	const char *p = str, *pe = end ? end : str + strlen( str ), *eof = pe;
	int cs;
	out = out ? out : (char*)str;
	uint16_t u = 0;
	%%{
		machine ejson_str;

		xxdigit = (
			([0-9] @{ u = (u << 4) | (fc - '0'); }) |
			([a-f] @{ u = (u << 4) | (fc - 'a' + 0xa); }) |
			([A-F] @{ u = (u << 4) | (fc - 'A' + 0xa); })			
		);
		utf16 = ( xxdigit{4} ) >{ u = 0; } @{ out = ejson_append_utf8_glyph(out, u); };
		
		normal = any @{*out++ = fc;};
		escape = 
				('"' %{ *out++ = '"'; } ) |
				('\\' %{ *out++ = '\\'; } ) |
				('t' %{ *out++ = '\t'; } )  |
				('b' %{ *out++ = '\b'; } )  |
				('f' %{ *out++ = '\f'; } )  |
				('n' %{ *out++ = '\n'; } )  |
				('r' %{ *out++ = '\r'; } )  |
				('u' utf16 ) |
				(( any -- [\\tbfntu\"] ) %{*out++ = fc;})
			;
		main := (
			('\\' escape) |
			( normal -- '\\' )
		)*;
		
		# Initialize and execute.
		write init;
		write exec;
	}%%
	*out = 0;
	
	return 0;
}

%%{
	machine ejson;
	write data;
}%%

int ejson_parse( ejson_driver_t *d, const char * str )
{
	const char *p = str, *pe = str + strlen( str ), *eof = pe;
	int cs;
	int stack[48], top = 0;
	int integer_sign = 0;	// for integer decode
	const char * float_start = NULL;
	ejson_driver_value_t v; // = {0};
	uint32_t b64 = 0;
	int b64_cnt = 0;
	uint8_t * base64 = NULL;
	int base64_hold = 0;
	const char * _value_start = NULL;
	
	memset(&v, 0, sizeof(v));
	%%{
		machine ejson;
		action obj_field_list_start { d->open_object(d); }
		action obj_field_list_done { d->close_object(d); }
		action obj_value_list_start { d->open_array(d); }
		action obj_value_list_done { d->close_array(d); }
		action obj_create_name { d->set_name(d, &v); }
		action obj_set_flag { if (d->add_flag) d->add_flag(d, &v); }
		action obj_set_string { d->set_value(d, ejson_driver_type_string, &v); }
		action obj_set_integer { d->set_value(d, ejson_driver_type_integer, &v); }
		action obj_set_float { d->set_value(d, ejson_driver_type_float, &v); }
		action obj_set_hex { d->set_value(d, ejson_driver_type_hex, &v); }
		action obj_set_true { v.u.v_bool = 1; d->set_value(d, ejson_driver_type_bool, &v); }
		action obj_set_false { v.u.v_bool = 0; d->set_value(d, ejson_driver_type_bool, &v); }
		action obj_set_null { d->set_value(d, ejson_driver_type_null, NULL); }
		
		action obj_start_data { 
			if (d->open_data) {
				d->open_data(d);
				base64_hold = 0;
				if (!base64)
					base64 = (uint8_t*)alloca(128);
			}
		}
		action obj_flush_data {
			if (base64_hold + b64_cnt >= 128) {
				if (d->add_data)
					d->add_data(d, base64, base64_hold);
				base64_hold = 0;
			}
			for (int s=16, i = 0; i < b64_cnt; i++, s-=8) 
				base64[base64_hold++] = (b64 >> s) & 0xff;
		}
		action obj_end_data { 
			if (base64_hold && d->add_data)
				d->add_data(d, base64, base64_hold);
			if (d->close_data) d->close_data(d);
		}
		
		W = (
			[ \t\n]**
		);

		#
		# quoted or unquoted string
		#
		action str_init { v.u.v_str.start = v.u.v_str.end = fpc; }
		action str_done { v.u.v_str.end = fpc; }
			
		string = '"' ((([^"] | '\\"')**) >str_init %str_done)  '"';
		ident = ((alpha | '_') (alnum | '_')**) >str_init %str_done;
		
		#
		#	negative/positive Integer
		#
		action integer_init { v.u.v_int = 0; integer_sign = 1; }
		action integer_minus { integer_sign = -1; }
		action integer_digit { v.u.v_int = (v.u.v_int * 10) + (fc - '0'); }
		action integer_done {  v.u.v_int *= integer_sign; }
		
		integer = (('-' @integer_minus | '+')? (digit+ @integer_digit)) 
			>integer_init %integer_done;
		
		#
		# hex integer
		#
		xxdigit = (
			([0-9] @{ v.u.v_int = (v.u.v_int << 4) | (fc - '0'); }) |
			([a-f] @{ v.u.v_int = (v.u.v_int << 4) | (fc - 'a' + 0xa); }) |
			([A-F] @{ v.u.v_int = (v.u.v_int << 4) | (fc - 'A' + 0xa); })			
		);
		hex = (('-' @integer_minus | '+')?( '0x' xxdigit+))
			>integer_init %integer_done;
		
		#
		# float/double value
		#
		action float_init { float_start = fpc; }
		action float_done { sscanf(float_start, "%lf", &v.u.v_float); }
		#
		# float values
		#
		float = (
			('-' | '+')? digit* '.' digit+ [fd]?
		) >float_init %float_done;

		#
		# base64 decoder
		#
		base64_char = (
			([A-Z] @{ b64 = (b64 << 6) | (fc - 'A'); }) |
			([a-z] @{ b64 = (b64 << 6) | (fc - 'a' + 26 ); }) |
			([0-9] @{ b64 = (b64 << 6) | (fc - '0' + 52 ); }) |
			('+' @{ b64 = (b64 << 6) | 62; }) |
			('/' @{ b64 = (b64 << 6) | 63; })
		);
		base64_pad = '=' @{ b64 = (b64 << 6); };
		base64_four = (
			base64_char base64_char base64_char base64_char
		) %{ b64_cnt = 3; } %obj_flush_data;
		base64_padder = (
			base64_char base64_char
			(
				(( base64_char base64_pad ) 
					%{ b64_cnt = 2; } ) |
				(( base64_pad base64_pad ) 
					%{ b64_cnt = 1; } )
			)
		) %obj_flush_data;

		base64 = ( base64_four** (base64_four | base64_padder) ) >{b64 = 0;} 
				%err{ printf("### base64 Error : '%s'\n", p); };

		#
		# ejson value, extended
		#
		ejson_value = (
			(string %obj_set_string) |
			(integer %obj_set_integer) |
			(hex %obj_set_hex ) |
			(float %obj_set_float) |
			('true' %obj_set_true) |
			('false' %obj_set_false) |
			('null' %obj_set_null) |
			('{' @{ fhold; fcall obj_field_list; } ) |
			('[' @{ fhold; fcall ejson_value_list; } ) |
			(('%' (W base64)* W '%') >obj_start_data %obj_end_data)
		) >{ _value_start = p; }
				%err{ printf("### Value[%d] Error : '%s'\n", top, _value_start); };
		
		ejson_value_list := (
			'[' W
				( W (ejson_value (W ',' W ejson_value)* ) W ','? )?
			W ']'
		) >obj_value_list_start @obj_value_list_done @{ fret; } 
				%err{ printf("### Array[%d] Error : '%s'\n", top, p); };
		
		obj_field_flag = ( ident ) %obj_set_flag;
		obj_field_flags = (
			'(' W obj_field_flag (W ',' W obj_field_flag)* W  ','? W ')'
		);
		obj_field = ((string | ident) %obj_create_name) W obj_field_flags? W ':' W ejson_value;
		
		obj_field_list := (
			'{' W
				( W (obj_field (W ',' W obj_field)** ) W ','? )?
			 W '}'
		) >obj_field_list_start @obj_field_list_done @{ fret; }
				%err{ printf("### Object[%d] Error : '%s'\n", top, p); };
		
		main := (
			W ejson_value W
		) %err{ printf("### ejson Error : '%s'\n", p); };

		# Initialize and execute.
		write init;
		write exec;
	}%%
	
	return 0;
};

